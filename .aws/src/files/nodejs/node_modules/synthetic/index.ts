// adapted from https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/CloudWatch_Synthetics_Canaries_Samples.html
// probably this is to be moved into own, small javascript package at some point.

// https://www.npmjs.com/package/@aws-cdk/aws-synthetics
const synthetics = require('Synthetics');
const log = require('SyntheticsLogger');
const syntheticsConfiguration = synthetics.getConfiguration();
const syntheticsLogHelper = require('SyntheticsLogHelper');
const jmespath = require('../jmespath/jmespath'); // expected synthetic structure - deps zipped w/synthetic code

const getValidUrl = (url = "") => {
  var pattern = /^((http|https):\/\/)/;

  if (url === "") {
    throw new Error(`Error: empty URL envvar`);
  }

  if (!pattern.test(url)) {
    // default to https if not present
    url = "https://" + url;
  }
  return url;
};

const checkUptime = async function () {
  const url = getValidUrl(process.env.UPTIME_URL || "");
  const responseCheck = process.env.UPTIME_BODY || "";

  syntheticsConfiguration.disableStepScreenshots();
  syntheticsConfiguration.setConfig({
    continueOnStepFailure: true,
    includeRequestHeaders: true,
    includeResponseHeaders: true,
    restrictedHeaders: [],
    restrictedUrlParameters: [],
  });

  // makes a puppeteer object for synthetics
  let page = await synthetics.getPage();
  await loadUrl(page, url, responseCheck);
};

const loadUrl = async function (page, url: string, responseCheck: string) {
  let stepName = "";
  let domcontentloaded = false;

  try {
    stepName = new URL(url).hostname;
  } catch (error) {
    log.error(`Error parsing url ${url} : ${error}`);
    throw error;
  }

  await synthetics.executeStep(stepName, async function () {
    const sanitizedUrl = syntheticsLogHelper.getSanitizedUrl(url);
    // https://pptr.dev/api/puppeteer.httpresponse
    const response = await page.goto(url, {
      waitUntil: ['domcontentloaded'],
      timeout: 30000,
    });
    if (response) {
      domcontentloaded = true;
      const responseText = await response.text();
      const status = response.status();
      const statusText = response.statusText();

      if (status < 200 || status > 299) {
        throw new Error(`Non-2XX response: ${sanitizedUrl} ${status} ${statusText}`);
      };

      if (responseText !== responseCheck) {
        throw new Error(`Not expected response. Expected: ${responseCheck} Received: ${responseText}`);
      };

      log.info(`Response: ${sanitizedUrl}  Status: ${status}  Status Text: ${statusText}`);
    } else {
      const logNoResponseString = `No response: ${sanitizedUrl}`;
      throw new Error(logNoResponseString);
    };
  });
};

const checkQuery = async function () {
  const endpoint = process.env.GRAPHQL_ENDPOINT || "";
  const queryJmespath = process.env.GRAPHQL_JMESPATH || "";
  const query = process.env.GRAPHQL_QUERY || "";
  const responseCheck = process.env.GRAPHQL_RESPONSE || "";

  syntheticsConfiguration.disableStepScreenshots();
  syntheticsConfiguration.setConfig({
    continueOnStepFailure: true,
    includeRequestHeaders: true,
    includeResponseHeaders: true,
    restrictedHeaders: [],
    restrictedUrlParameters: [],
  });

  const validateSuccessful = async res => {
    return new Promise<void>((resolve, reject) => {
      if (res.statusCode < 200 || res.statusCode > 299) {
        throw new Error(`${res.statusCode} ${res.statusMessage}`);
      };

      let responseRaw = '';
      res.on('data', (d) => {
        responseRaw += d;
      });

      res.on('end', () => {
        const bodyJson = JSON.parse(responseRaw);
        if (queryJmespath === '') {
          const response = JSON.stringify(bodyJson);
          if (response !== responseCheck) {
            throw new Error(`Not expected response. Received: ${response} Expected: ${responseCheck}`);
          };
        } else {
          const response = jmespath.search(bodyJson, queryJmespath);
          if (response !== responseCheck) {
            throw new Error(`Not expected response. Received: ${response} Expected: ${responseCheck}`);
          };
        };
        resolve();
      });
    });
  };

  let requestOptions = {
    body: query,
    headers: { "Content-Type": "application/json" },
    hostname: endpoint,
    method: 'POST',
    protocol: 'https:',
  };
  requestOptions['headers']['User-Agent'] = [synthetics.getCanaryUserAgentString(), requestOptions['headers']['User-Agent']].join(' ');

  let stepConfig = {
    includeRequestHeaders: true,
    includeResponseHeaders: true,
    includeRequestBody: true,
    includeResponseBody: true,
    continueOnHttpStepFailure: true
  };

  await synthetics.executeHttpStep('Verify GraphQL Query', requestOptions, validateSuccessful, stepConfig);
};

exports.uptime = async () => {
  return await checkUptime();
};

exports.query = async () => {
  return await checkQuery();
};
